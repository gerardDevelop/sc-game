{"version":3,"sources":["App.js","serviceWorker.js","Scenes/MainScene.js","index.js","logo.svg"],"names":["App","react_default","a","createElement","className","src","logo","alt","href","target","rel","Component","Boolean","window","location","hostname","match","MainScene","test","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","key","mainScene","assertThisInitialized","posSendTimer","characters","myCharacter","NPCs","projectiles","playerToMove","x","y","load","spritesheet","frameWidth","frameHeight","console","log","_this2","player","add","sprite","innerWidth","innerHeight","scale","on","gameSize","baseSize","displaySize","resolution","cameras","main","setViewport","width","height","graphics","lineStyle","color","fillStyle","alpha","fillRect","fillRoundedRect","onMainFinishedLoading","time","delta","fakeServer","update","startFollow","Phaser","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","config","type","pixelArt","parent","physics","default","scene","mode","RESIZE","module","exports","__webpack_require__","p"],"mappings":"iNA2BeA,2LArBX,OACEC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAAA,UAAQC,UAAU,cAChBH,EAAAC,EAAAC,cAAA,OAAKE,IAAKC,IAAMF,UAAU,WAAWG,IAAI,SACzCN,EAAAC,EAAAC,cAAA,iBACOF,EAAAC,EAAAC,cAAA,0BADP,wBAGAF,EAAAC,EAAAC,cAAA,KACEC,UAAU,WACVI,KAAK,sBACLC,OAAO,SACPC,IAAI,uBAJN,wBATQC,cCQEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,gFCgLSC,cA/LX,SAAAA,EAAaC,GAAM,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,GACfE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAM,CACFI,IAAK,eAGTb,OAAOc,UAAPP,OAAAQ,EAAA,EAAAR,QAAAQ,EAAA,EAAAR,CAAAD,IAEAA,EAAKU,aAAe,EAEpBV,EAAKW,WAAa,GAElBX,EAAKY,YAAc,KAEnBZ,EAAKa,KAAO,GAEZb,EAAKc,YAAc,GAEnBd,EAAKe,aAAe,CAChBC,EAAG,EACHC,EAAG,GAnBQjB,yEA6CfG,KAAKe,KAAKC,YAAY,SAAU,kCAAmC,CAC/DC,WAAY,GACZC,YAAa,KAGjBC,QAAQC,IAAI,iDAgBN,IAAAC,EAAArB,KACNA,KAAKsB,OAAStB,KAAKuB,IAAIC,OACnBjC,OAAOkC,WAAa,EACpBlC,OAAOmC,YAAc,EACrB,UAGJ1B,KAAK2B,MAAMC,GAAG,SAAU,SAACC,EAAUC,EAAUC,EAAaC,GAEtDX,EAAKY,QAAQC,KAAKC,YAAY,EAAG,EAAGL,EAASM,MAAON,EAASO,UAqCjE,IAAIC,EAAWtC,KAAKuB,IAAIe,SAAS,CAC7BC,UAAW,CAAEH,MAAO,EAAGI,MAAO,UAC9BC,UAAW,CAAED,MAAO,SAAUE,MAAO,MAGzCJ,EAASK,SACLpD,OAAOkC,WAAa,EAAI,GACxBlC,OAAOmC,YAAc,EAAI,GACzB,GACA,IAKJY,EAASM,gBACL,IACA,IACA,GACA,GACA,IAIJzB,QAAQC,IAAI,qBAEZ7B,OAAOsD,uDAGHC,EAAMC,GAGVxD,OAAOyD,WAAWC,OAAOH,EAAMC,GAE/BA,GAAS,IAEmB,IAAxB/C,KAAKY,aAAaC,IAAUb,KAAKsB,OAAOT,GAAKb,KAAKY,aAAaC,EAAIkC,EAAQ,IACnD,IAAxB/C,KAAKY,aAAaE,IAAUd,KAAKsB,OAAOR,GAAKd,KAAKY,aAAaE,EAAIiC,EAAQ,IAE/E/C,KAAKiC,QAAQC,KAAKgB,YAAYlD,KAAKsB,eAvJnB6B,SCMxBC,IAASC,OAAO1E,EAAAC,EAAAC,cAACyE,EAAD,MAASC,SAASC,eAAe,SFyH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,eEpHnB,IAAIC,EAAS,CACTC,KAAMb,QACNc,UAAU,EAEVC,OAAQ,iBACR9B,MAAO7C,OAAOkC,WACdY,OAAQ9C,OAAOmC,YACfyC,QAAS,CACLC,QAAS,UAEbC,MAAO,CAAC1E,GACRgC,MAAO,CACHuC,OAAQ,iBACRI,KAAMnB,QAAaoB,OACnBnC,MAAO7C,OAAOkC,WACdY,OAAQ9C,OAAOmC,cAIZ,IAAIyB,OAAYY,wBClC3BS,EAAAC,QAAiBC,EAAAC,EAAuB","file":"static/js/main.cac31b3b.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <a\n            className=\"App-link\"\n            href=\"https://reactjs.org\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn React\n          </a>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as Phaser from 'phaser';\n\nclass MainScene extends Phaser.Scene {\n    constructor (test) {\n        super({\n            key: 'MainScene'\n        });\n\n        window.mainScene = this;\n\n        this.posSendTimer = 0;\n\n        this.characters = {}; // should contain refs to all nearby user controlled characters\n\n        this.myCharacter = null;\n\n        this.NPCs = {}; // should contain refs to all nearby npcs\n\n        this.projectiles = {};\n\n        this.playerToMove = {\n            x: 0,\n            y: 0\n        };\n    }\n\n    // todo: clean this all up\n\n    preload () {\n    /*\n        this.load.image(\n            \"tiles\",\n            \"../assets/tilesets/tiles-extruded-name.png\"\n        );\n\n        this.load.tilemapTiledJSON(\n            \"map\",\n            \"../assets/tilemaps/tilemapname.json\"\n        );\n        */\n        /*\n        this.load.spritesheet('warrior', 'assets/sprites/warrior_test.png',\n            { frameWidth: 32, frameHeight: 32 });\n        */\n        /*\n        this.load.scenePlugin('animatedTiles', AnimatedTiles, 'animatedTiles', 'animatedTiles');\n        */\n\n        this.load.spritesheet('player', './assets/initialspritesheet.png', {\n            frameWidth: 17,\n            frameHeight: 19\n        });\n\n        console.log('in mainscene');\n    }\n    /*\n    resize (width, height) {\n        if (width === undefined) {\n            width = this.sys.game.config.width;\n        }\n        if (height === undefined) {\n            height = this.sys.game.config.height;\n        }\n\n        this.cameras.resize(width, height);\n        console.log('resized!');\n    //this.cameras.main.setViewport(0, 0, width, height);\n    }\n    */\n    create () {\n        this.player = this.add.sprite(\n            window.innerWidth / 2,\n            window.innerHeight / 2,\n            'player'\n        );\n\n        this.scale.on('resize', (gameSize, baseSize, displaySize, resolution) => {\n            //console.log(\"resize called\");\n            this.cameras.main.setViewport(0, 0, baseSize.width, baseSize.height);\n        });\n\n        /*\n      const camera = this.cameras.main;\n\n      //camera.setZoom();\n\n      // Set up the arrows to control the camera\n      const cursors = this.input.keyboard.createCursorKeys();\n      this.controls = new Phaser.Cameras.Controls.FixedKeyControl({\n        camera: camera,\n        left: cursors.left,\n        right: cursors.right,\n        up: cursors.up,\n        down: cursors.down,\n        speed: 0.75\n      });\n      */\n        /*\n     const map = this.make.tilemap({ key: \"map\" });\n\n     const tiles = map.addTilesetImage(\n     \"0x72-industrial-tileset-32px-extruded\",\n     \"tiles\"\n\n     map.createDynamicLayer(\"Background\", tiles);\n     this.groundLayer = map.createDynamicLayer(\"Ground\", tiles);\n     map.createDynamicLayer(\"Foreground\", tiles);\n     */\n        //);\n\n        // this.mainSprite = this.add.sprite(1, 1, 'warrior');\n\n        //var newPlayer = new Player(this);\n        // this.myPlayer = new MyPlayer(newPlayer);\n\n        var graphics = this.add.graphics({\n            lineStyle: { width: 2, color: 0xaa0000 },\n            fillStyle: { color: 0xc1c1c1, alpha: 0.3 }\n        });\n\n        graphics.fillRect(\n            window.innerWidth / 2 - 11,\n            window.innerHeight / 2 - 11,\n            24,\n            24\n        );\n\n        // also draw graphics for joystick\n\n        graphics.fillRoundedRect(\n            100,\n            100,\n            50,\n            50,\n            50\n        );\n        //graphics.fillRoundedRect(25, window.innerHeight - 100, 26, 26, 13);\n\n        console.log('created mainScene');\n\n        window.onMainFinishedLoading();\n    }\n\n    update (time, delta) {\n\n        // update fakeServer\n        window.fakeServer.update(time, delta);\n\n        delta /= 1000;\n\n        if (this.playerToMove.x !== 0) {this.player.x += this.playerToMove.x * delta * 50;}\n        if (this.playerToMove.y !== 0) {this.player.y += this.playerToMove.y * delta * 50;}\n\n        this.cameras.main.startFollow(this.player);\n\n    /*\n\n        if(window.keysDown[window.keyBindings.moveUp]) {\n            this.myPlayer.player.sprite.y -= 100 *delta;\n        }\n        if(window.keysDown[window.keyBindings.moveDown]) {\n            this.myPlayer.player.sprite.y += 100 *delta;\n        }\n        if(window.keysDown[window.keyBindings.moveLeft]) {\n            this.myPlayer.player.sprite.x -= 100 *delta;\n        }\n        if(window.keysDown[window.keyBindings.moveRight]) {\n            this.myPlayer.player.sprite.x += 100 *delta;\n        }\n\n        // after input is resolved, send info about new player's position to the server\n        this.posSendTimer += delta;\n\n        if(this.posSendTimer > 0.1) {\n            if(this.myPlayer.isInDifferentPosition()) {\n\n                //broadcast new pos here\n                window.networkClient.sendPositionUpdate(this.myPlayer.player.sprite.x,\n                    this.myPlayer.player.sprite.y);\n\n                this.myPlayer.setOldPos(this.myPlayer.player.sprite.x,\n                    this.myPlayer.player.sprite.y);\n\n                this.posSendTimer = 0;\n            }\n        }\n\n        // todo - make a more manual camera follow solution, however for now, this is fine\n\n\n        */\n    }\n}\n\nexport default MainScene;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport MainScene from './Scenes/MainScene';\nimport * as Phaser from 'phaser';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\nvar config = {\n    type: Phaser.WEBGL,\n    pixelArt: true,\n    //roundPixels: true,\n    parent: 'phaser-content',\n    width: window.innerWidth,\n    height: window.innerHeight,\n    physics: {\n        default: 'arcade'\n    },\n    scene: [MainScene],\n    scale: {\n        parent: 'phaser-content',\n        mode: Phaser.Scale.RESIZE,\n        width: window.innerWidth,\n        height: window.innerHeight\n    }\n};\n\nvar main = new Phaser.Game(config);","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}